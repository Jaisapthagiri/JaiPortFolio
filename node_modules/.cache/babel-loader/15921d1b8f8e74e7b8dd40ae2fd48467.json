{"ast":null,"code":"import isEqual from 'react-fast-compare';\nimport { lerp, random, randomElement, twoPi } from './utils.js';\nexport const defaultConfig = {\n  color: '#dee4fd',\n  radius: [0.5, 3.0],\n  speed: [1.0, 3.0],\n  wind: [-0.5, 2.0],\n  changeFrequency: 200,\n  rotationSpeed: [-1.0, 1.0],\n  opacity: [1, 1]\n};\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\n\nclass Snowflake {\n  /**\r\n   * A utility function to create a collection of snowflakes\r\n   * @param canvas The canvas element\r\n   * @param amount The number of snowflakes\r\n   * @param config The configuration for each snowflake\r\n   */\n  static createSnowflakes(canvas, amount, config) {\n    if (!canvas) return [];\n    const snowflakes = [];\n\n    for (let i = 0; i < amount; i++) {\n      snowflakes.push(new Snowflake(canvas, config));\n    }\n\n    return snowflakes;\n  }\n\n  constructor(canvas) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Set custom config\n    this.updateConfig(config); // Setting initial parameters\n\n    const {\n      radius,\n      wind,\n      speed,\n      rotationSpeed,\n      opacity\n    } = this.config;\n    this.params = {\n      x: random(0, canvas.offsetWidth),\n      y: random(-canvas.offsetHeight, 0),\n      rotation: random(0, 360),\n      radius: random(...radius),\n      speed: random(...speed),\n      wind: random(...wind),\n      rotationSpeed: random(...rotationSpeed),\n      nextSpeed: random(...speed),\n      nextWind: random(...wind),\n      nextRotationSpeed: random(...rotationSpeed),\n      opacity: random(...opacity)\n    };\n    this.framesSinceLastUpdate = 0;\n  }\n\n  selectImage() {\n    if (this.config.images && this.config.images.length > 0) {\n      this.image = randomElement(this.config.images);\n    } else {\n      this.image = undefined;\n    }\n  }\n\n  updateConfig(config) {\n    const previousConfig = this.config;\n    this.config = { ...defaultConfig,\n      ...config\n    };\n    this.config.changeFrequency = random(this.config.changeFrequency, this.config.changeFrequency * 1.5); // Update the radius if the config has changed, it won't gradually update on it's own\n\n    if (this.params && !isEqual(this.config.radius, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.radius)) {\n      this.params.radius = random(...this.config.radius);\n    }\n\n    if (!isEqual(this.config.images, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.images)) {\n      this.selectImage();\n    }\n  }\n\n  updateTargetParams() {\n    this.params.nextSpeed = random(...this.config.speed);\n    this.params.nextWind = random(...this.config.wind);\n\n    if (this.image) {\n      this.params.nextRotationSpeed = random(...this.config.rotationSpeed);\n    }\n  }\n\n  update(offsetWidth, offsetHeight) {\n    let framesPassed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const {\n      x,\n      y,\n      rotation,\n      rotationSpeed,\n      nextRotationSpeed,\n      wind,\n      speed,\n      nextWind,\n      nextSpeed,\n      radius\n    } = this.params; // Update current location, wrapping around if going off the canvas\n\n    this.params.x = (x + wind * framesPassed) % (offsetWidth + radius * 2);\n    if (this.params.x > offsetWidth + radius) this.params.x = -radius;\n    this.params.y = (y + speed * framesPassed) % (offsetHeight + radius * 2);\n    if (this.params.y > offsetHeight + radius) this.params.y = -radius; // Apply rotation\n\n    if (this.image) {\n      this.params.rotation = (rotation + rotationSpeed) % 360;\n    } // Update the wind, speed and rotation towards the desired values\n\n\n    this.params.speed = lerp(speed, nextSpeed, 0.01);\n    this.params.wind = lerp(wind, nextWind, 0.01);\n    this.params.rotationSpeed = lerp(rotationSpeed, nextRotationSpeed, 0.01);\n\n    if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\n      this.updateTargetParams();\n      this.framesSinceLastUpdate = 0;\n    }\n  }\n\n  getImageOffscreenCanvas(image, size) {\n    var _a, _b;\n\n    if (image instanceof HTMLImageElement && image.loading) return image;\n    let sizes = Snowflake.offscreenCanvases.get(image);\n\n    if (!sizes) {\n      sizes = {};\n      Snowflake.offscreenCanvases.set(image, sizes);\n    }\n\n    if (!(size in sizes)) {\n      const canvas = document.createElement('canvas');\n      canvas.width = size;\n      canvas.height = size;\n      (_a = canvas.getContext('2d')) === null || _a === void 0 ? void 0 : _a.drawImage(image, 0, 0, size, size);\n      sizes[size] = canvas;\n    }\n\n    return (_b = sizes[size]) !== null && _b !== void 0 ? _b : image;\n  }\n  /**\r\n   * Draws a circular snowflake to the canvas.\r\n   *\r\n   * This method should only be called if our config does not have images.\r\n   *\r\n   * This method assumes that a path has already been started on the canvas.\r\n   * `ctx.beginPath()` should be called before calling this method.\r\n   *\r\n   * After calling this method, the fillStyle should be set to the snowflake's\r\n   * color and `ctx.fill()` should be called to fill the snowflake.\r\n   *\r\n   * Calling `ctx.fill()` after multiple snowflakes have had `drawCircle` called\r\n   * will render all of the snowflakes since the last call to `ctx.beginPath()`.\r\n   *\r\n   * @param ctx The canvas context to draw to\r\n   */\n\n\n  drawCircle(ctx) {\n    ctx.moveTo(this.params.x, this.params.y);\n    ctx.arc(this.params.x, this.params.y, this.params.radius, 0, twoPi);\n  }\n  /**\r\n   * Draws an image-based snowflake to the canvas.\r\n   *\r\n   * This method should only be called if our config has images.\r\n   *\r\n   * @param ctx The canvas context to draw to\r\n   */\n\n\n  drawImage(ctx) {\n    const {\n      x,\n      y,\n      rotation,\n      radius\n    } = this.params;\n    const radian = rotation * Math.PI / 180;\n    const cos = Math.cos(radian);\n    const sin = Math.sin(radian); // Save the current state to avoid affecting other drawings if changing the opacity\n\n    if (this.params.opacity !== 1) {\n      ctx.save();\n      ctx.globalAlpha = this.params.opacity; // Set the global alpha to the snowflake's opacity\n    } // Translate to the location that we will be drawing the snowflake, including any rotation that needs to be applied\n    // The arguments for setTransform are: a, b, c, d, e, f\n    // a (scaleX), b (skewY), c (skewX), d (scaleY), e (translateX), f (translateY)\n\n\n    ctx.setTransform(cos, sin, -sin, cos, x, y); // Draw the image with the center of the image at the center of the current location\n\n    const image = this.getImageOffscreenCanvas(this.image, radius);\n    ctx.drawImage(image, -(radius / 2), -(radius / 2), radius, radius); // Reset the transform to avoid affecting other drawings if we were changing the opacity\n\n    if (this.params.opacity !== 1) {\n      ctx.restore();\n    }\n  }\n\n}\n\nSnowflake.offscreenCanvases = new WeakMap();\nexport default Snowflake;","map":{"version":3,"mappings":"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","names":["isEqual","lerp","random","randomElement","twoPi","defaultConfig","color","radius","speed","wind","changeFrequency","rotationSpeed","opacity","Snowflake","createSnowflakes","canvas","amount","config","snowflakes","i","push","constructor","updateConfig","params","x","offsetWidth","y","offsetHeight","rotation","nextSpeed","nextWind","nextRotationSpeed","framesSinceLastUpdate","selectImage","images","length","image","undefined","previousConfig","updateTargetParams","update","framesPassed","getImageOffscreenCanvas","size","HTMLImageElement","loading","sizes","offscreenCanvases","get","set","document","createElement","width","height","getContext","_a","drawImage","_b","drawCircle","ctx","moveTo","arc","radian","Math","PI","cos","sin","save","globalAlpha","setTransform","restore","WeakMap"],"sources":["D:\\PortFolio\\node_modules\\react-snowfall\\src\\Snowflake.ts"],"sourcesContent":["import isEqual from 'react-fast-compare'\r\nimport { lerp, random, randomElement, twoPi } from './utils.js'\r\n\r\nexport interface SnowflakeProps {\r\n  /** The color of the snowflake, can be any valid CSS color. */\r\n  color: string\r\n  /**\r\n   * The minimum and maximum radius of the snowflake, will be\r\n   * randomly selected within this range.\r\n   *\r\n   * The default value is `[0.5, 3.0]`.\r\n   */\r\n  radius: [number, number]\r\n  /**\r\n   * The minimum and maximum speed of the snowflake.\r\n   *\r\n   * The speed determines how quickly the snowflake moves\r\n   * along the y axis (vertical speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[1.0, 3.0]`.\r\n   */\r\n  speed: [number, number]\r\n  /**\r\n   * The minimum and maximum wind of the snowflake.\r\n   *\r\n   * The wind determines how quickly the snowflake moves\r\n   * along the x axis (horizontal speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-0.5, 2.0]`.\r\n   */\r\n  wind: [number, number]\r\n  /**\r\n   * The frequency in frames that the wind and speed values\r\n   * will update.\r\n   *\r\n   * The default value is 200.\r\n   */\r\n  changeFrequency: number\r\n  /**\r\n   * An array of images that will be rendered as the snowflakes instead\r\n   * of the default circle shapes.\r\n   */\r\n  images?: CanvasImageSource[]\r\n  /**\r\n   * The minimum and maximum rotation speed of the snowflake (in degrees of\r\n   * rotation per frame).\r\n   *\r\n   * The rotation speed determines how quickly the snowflake rotates when\r\n   * an image is being rendered.\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-1.0, 1.0]`.\r\n   */\r\n  rotationSpeed: [number, number]\r\n  /**\r\n   * The minimum and maximum opacity of the snowflake image.\r\n   *\r\n   * This value only applies to snowflakes that are using images.\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[1, 1]`.\r\n   */\r\n  opacity: [number, number]\r\n}\r\n\r\nexport type SnowflakeConfig = Partial<SnowflakeProps>\r\n\r\nexport const defaultConfig: SnowflakeProps = {\r\n  color: '#dee4fd',\r\n  radius: [0.5, 3.0],\r\n  speed: [1.0, 3.0],\r\n  wind: [-0.5, 2.0],\r\n  changeFrequency: 200,\r\n  rotationSpeed: [-1.0, 1.0],\r\n  opacity: [1, 1],\r\n}\r\n\r\ninterface SnowflakeParams {\r\n  x: number\r\n  y: number\r\n  radius: number\r\n  rotation: number\r\n  rotationSpeed: number\r\n  speed: number\r\n  wind: number\r\n  nextSpeed: number\r\n  nextWind: number\r\n  nextRotationSpeed: number\r\n  opacity: number\r\n}\r\n\r\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\r\nclass Snowflake {\r\n  private static offscreenCanvases = new WeakMap<CanvasImageSource, Record<number, HTMLCanvasElement>>()\r\n\r\n  /**\r\n   * A utility function to create a collection of snowflakes\r\n   * @param canvas The canvas element\r\n   * @param amount The number of snowflakes\r\n   * @param config The configuration for each snowflake\r\n   */\r\n  static createSnowflakes(canvas: HTMLCanvasElement | null, amount: number, config: SnowflakeConfig): Snowflake[] {\r\n    if (!canvas) return []\r\n\r\n    const snowflakes: Snowflake[] = []\r\n\r\n    for (let i = 0; i < amount; i++) {\r\n      snowflakes.push(new Snowflake(canvas, config))\r\n    }\r\n\r\n    return snowflakes\r\n  }\r\n\r\n  private config!: SnowflakeProps\r\n  private params: SnowflakeParams\r\n  private framesSinceLastUpdate: number\r\n  private image?: CanvasImageSource\r\n\r\n  public constructor(canvas: HTMLCanvasElement, config: SnowflakeConfig = {}) {\r\n    // Set custom config\r\n    this.updateConfig(config)\r\n\r\n    // Setting initial parameters\r\n    const { radius, wind, speed, rotationSpeed, opacity } = this.config\r\n\r\n    this.params = {\r\n      x: random(0, canvas.offsetWidth),\r\n      y: random(-canvas.offsetHeight, 0),\r\n      rotation: random(0, 360),\r\n      radius: random(...radius),\r\n      speed: random(...speed),\r\n      wind: random(...wind),\r\n      rotationSpeed: random(...rotationSpeed),\r\n      nextSpeed: random(...speed),\r\n      nextWind: random(...wind),\r\n      nextRotationSpeed: random(...rotationSpeed),\r\n      opacity: random(...opacity),\r\n    }\r\n\r\n    this.framesSinceLastUpdate = 0\r\n  }\r\n\r\n  private selectImage() {\r\n    if (this.config.images && this.config.images.length > 0) {\r\n      this.image = randomElement(this.config.images)\r\n    } else {\r\n      this.image = undefined\r\n    }\r\n  }\r\n\r\n  public updateConfig(config: SnowflakeConfig): void {\r\n    const previousConfig = this.config\r\n    this.config = { ...defaultConfig, ...config }\r\n    this.config.changeFrequency = random(this.config.changeFrequency, this.config.changeFrequency * 1.5)\r\n\r\n    // Update the radius if the config has changed, it won't gradually update on it's own\r\n    if (this.params && !isEqual(this.config.radius, previousConfig?.radius)) {\r\n      this.params.radius = random(...this.config.radius)\r\n    }\r\n\r\n    if (!isEqual(this.config.images, previousConfig?.images)) {\r\n      this.selectImage()\r\n    }\r\n  }\r\n\r\n  private updateTargetParams(): void {\r\n    this.params.nextSpeed = random(...this.config.speed)\r\n    this.params.nextWind = random(...this.config.wind)\r\n    if (this.image) {\r\n      this.params.nextRotationSpeed = random(...this.config.rotationSpeed)\r\n    }\r\n  }\r\n\r\n  public update(offsetWidth: number, offsetHeight: number, framesPassed = 1): void {\r\n    const { x, y, rotation, rotationSpeed, nextRotationSpeed, wind, speed, nextWind, nextSpeed, radius } = this.params\r\n\r\n    // Update current location, wrapping around if going off the canvas\r\n    this.params.x = (x + wind * framesPassed) % (offsetWidth + radius * 2)\r\n    if (this.params.x > offsetWidth + radius) this.params.x = -radius\r\n    this.params.y = (y + speed * framesPassed) % (offsetHeight + radius * 2)\r\n    if (this.params.y > offsetHeight + radius) this.params.y = -radius\r\n\r\n    // Apply rotation\r\n    if (this.image) {\r\n      this.params.rotation = (rotation + rotationSpeed) % 360\r\n    }\r\n\r\n    // Update the wind, speed and rotation towards the desired values\r\n    this.params.speed = lerp(speed, nextSpeed, 0.01)\r\n    this.params.wind = lerp(wind, nextWind, 0.01)\r\n    this.params.rotationSpeed = lerp(rotationSpeed, nextRotationSpeed, 0.01)\r\n\r\n    if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\r\n      this.updateTargetParams()\r\n      this.framesSinceLastUpdate = 0\r\n    }\r\n  }\r\n\r\n  private getImageOffscreenCanvas(image: CanvasImageSource, size: number): CanvasImageSource {\r\n    if (image instanceof HTMLImageElement && image.loading) return image\r\n    let sizes = Snowflake.offscreenCanvases.get(image)\r\n\r\n    if (!sizes) {\r\n      sizes = {}\r\n      Snowflake.offscreenCanvases.set(image, sizes)\r\n    }\r\n\r\n    if (!(size in sizes)) {\r\n      const canvas = document.createElement('canvas')\r\n      canvas.width = size\r\n      canvas.height = size\r\n      canvas.getContext('2d')?.drawImage(image, 0, 0, size, size)\r\n      sizes[size] = canvas\r\n    }\r\n\r\n    return sizes[size] ?? image\r\n  }\r\n\r\n  /**\r\n   * Draws a circular snowflake to the canvas.\r\n   *\r\n   * This method should only be called if our config does not have images.\r\n   *\r\n   * This method assumes that a path has already been started on the canvas.\r\n   * `ctx.beginPath()` should be called before calling this method.\r\n   *\r\n   * After calling this method, the fillStyle should be set to the snowflake's\r\n   * color and `ctx.fill()` should be called to fill the snowflake.\r\n   *\r\n   * Calling `ctx.fill()` after multiple snowflakes have had `drawCircle` called\r\n   * will render all of the snowflakes since the last call to `ctx.beginPath()`.\r\n   *\r\n   * @param ctx The canvas context to draw to\r\n   */\r\n  public drawCircle(ctx: CanvasRenderingContext2D): void {\r\n    ctx.moveTo(this.params.x, this.params.y)\r\n    ctx.arc(this.params.x, this.params.y, this.params.radius, 0, twoPi)\r\n  }\r\n\r\n  /**\r\n   * Draws an image-based snowflake to the canvas.\r\n   *\r\n   * This method should only be called if our config has images.\r\n   *\r\n   * @param ctx The canvas context to draw to\r\n   */\r\n  public drawImage(ctx: CanvasRenderingContext2D): void {\r\n    const { x, y, rotation, radius } = this.params\r\n\r\n    const radian = (rotation * Math.PI) / 180\r\n    const cos = Math.cos(radian)\r\n    const sin = Math.sin(radian)\r\n\r\n    // Save the current state to avoid affecting other drawings if changing the opacity\r\n    if (this.params.opacity !== 1) {\r\n      ctx.save()\r\n      ctx.globalAlpha = this.params.opacity // Set the global alpha to the snowflake's opacity\r\n    }\r\n\r\n    // Translate to the location that we will be drawing the snowflake, including any rotation that needs to be applied\r\n    // The arguments for setTransform are: a, b, c, d, e, f\r\n    // a (scaleX), b (skewY), c (skewX), d (scaleY), e (translateX), f (translateY)\r\n    ctx.setTransform(cos, sin, -sin, cos, x, y)\r\n\r\n    // Draw the image with the center of the image at the center of the current location\r\n    const image = this.getImageOffscreenCanvas(this.image!, radius)\r\n    ctx.drawImage(image, -(radius / 2), -(radius / 2), radius, radius)\r\n\r\n    // Reset the transform to avoid affecting other drawings if we were changing the opacity\r\n    if (this.params.opacity !== 1) {\r\n      ctx.restore()\r\n    }\r\n  }\r\n}\r\n\r\nexport default Snowflake\r\n"]},"metadata":{},"sourceType":"module"}