{"ast":null,"code":"var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar _SnowfallCanvas_ctx, _SnowfallCanvas_canvas;\n\nimport Snowflake, { defaultConfig } from './Snowflake.js';\nimport { targetFrameTime } from './config.js';\nexport class SnowfallCanvas {\n  get ctx() {\n    return __classPrivateFieldGet(this, _SnowfallCanvas_ctx, \"f\");\n  }\n\n  get canvas() {\n    return __classPrivateFieldGet(this, _SnowfallCanvas_canvas, \"f\");\n  }\n\n  set canvas(canvas) {\n    __classPrivateFieldSet(this, _SnowfallCanvas_canvas, canvas, \"f\");\n\n    __classPrivateFieldSet(this, _SnowfallCanvas_ctx, canvas.getContext('2d'), \"f\");\n  }\n\n  constructor(canvas, config) {\n    this.lastUpdate = Date.now();\n    this.snowflakes = [];\n\n    _SnowfallCanvas_ctx.set(this, void 0);\n\n    _SnowfallCanvas_canvas.set(this, void 0);\n\n    __classPrivateFieldSet(this, _SnowfallCanvas_canvas, canvas, \"f\");\n\n    __classPrivateFieldSet(this, _SnowfallCanvas_ctx, canvas.getContext('2d'), \"f\");\n\n    this.config = {\n      snowflakeCount: 150,\n      ...defaultConfig,\n      ...config\n    };\n    this.snowflakes = [];\n    this.snowflakes = Snowflake.createSnowflakes(canvas, config.snowflakeCount || 150, config);\n    this.play();\n  }\n  /**\n   * Updates the config used for the snowfall animation, if the number of snowflakes\n   * has changed then this will create new or remove existing snowflakes gracefully\n   * to retain the position of as many existing snowflakes as possible.\n   */\n\n\n  updateConfig(config) {\n    this.config = { ...this.config,\n      ...config\n    };\n    const sizeDifference = this.config.snowflakeCount - this.snowflakes.length;\n\n    if (sizeDifference > 0) {\n      this.snowflakes = [...this.snowflakes, ...Snowflake.createSnowflakes(this.canvas, sizeDifference, config)];\n    }\n\n    if (sizeDifference < 0) {\n      this.snowflakes = this.snowflakes.slice(0, this.config.snowflakeCount);\n    }\n\n    for (const snowflake of this.snowflakes) {\n      snowflake.updateConfig(this.config);\n    }\n  }\n  /**\n   * Updates the location of each snowflake based on the number of frames passed then\n   * clears the canvas and draws each snowflake.\n   */\n\n\n  render() {\n    let framesPassed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    const {\n      ctx,\n      canvas,\n      snowflakes\n    } = this;\n    if (!ctx || !canvas) return;\n    const {\n      offsetWidth,\n      offsetHeight\n    } = canvas; // Update the position of each snowflake\n\n    for (const snowflake of snowflakes) {\n      snowflake.update(offsetWidth, offsetHeight, framesPassed);\n    } // Render the snowflakes\n\n\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, offsetWidth, offsetHeight); // If using images, draw each image individually\n\n    if (this.config.images && this.config.images.length > 0) {\n      for (const snowflake of snowflakes) {\n        snowflake.drawImage(ctx);\n      }\n\n      return;\n    } // Not using images, draw circles in a single path\n\n\n    ctx.beginPath();\n\n    for (const snowflake of snowflakes) {\n      snowflake.drawCircle(ctx);\n    }\n\n    ctx.fillStyle = this.config.color;\n    ctx.fill();\n  }\n  /**\n   * The animation loop, will calculate the time since the last render and update\n   * the position of the snowflakes appropriately before queueing another frame.\n   */\n\n\n  loop() {\n    // Update based on time passed so that a slow frame rate won't slow down the snowflake\n    const now = Date.now();\n    const msPassed = Date.now() - this.lastUpdate;\n    this.lastUpdate = now; // Frames that would have passed if running at 60 fps\n\n    const framesPassed = msPassed / targetFrameTime;\n    this.render(framesPassed);\n    this.animationFrame = requestAnimationFrame(() => this.loop());\n  }\n  /** Start the animation playing. */\n\n\n  play() {\n    this.loop();\n  }\n  /** Pause the animation. */\n\n\n  pause() {\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = undefined;\n    }\n  }\n\n}\n_SnowfallCanvas_ctx = new WeakMap(), _SnowfallCanvas_canvas = new WeakMap();\nexport default SnowfallCanvas;","map":{"version":3,"mappings":"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","names":["Snowflake","defaultConfig","targetFrameTime","SnowfallCanvas","ctx","__classPrivateFieldGet","_SnowfallCanvas_ctx","canvas","_SnowfallCanvas_canvas","__classPrivateFieldSet","getContext","constructor","config","Date","now","snowflakeCount","snowflakes","createSnowflakes","play","updateConfig","sizeDifference","length","slice","snowflake","render","framesPassed","offsetWidth","offsetHeight","update","setTransform","clearRect","images","drawImage","beginPath","drawCircle","fillStyle","color","fill","loop","msPassed","lastUpdate","animationFrame","requestAnimationFrame","pause","cancelAnimationFrame","undefined"],"sources":["D:\\PortFolio\\node_modules\\react-snowfall\\src\\SnowfallCanvas.ts"],"sourcesContent":["import Snowflake, { SnowflakeConfig, defaultConfig } from './Snowflake.js'\r\nimport { targetFrameTime } from './config.js'\r\n\r\nexport interface SnowfallCanvasConfig extends SnowflakeConfig {\r\n  /**\r\n   * The number of snowflakes to be rendered.\r\n   *\r\n   * The default value is 150.\r\n   */\r\n  snowflakeCount: number\r\n}\r\n\r\nexport class SnowfallCanvas {\r\n  private lastUpdate = Date.now()\r\n  private snowflakes: Snowflake[] = []\r\n  private config: SnowfallCanvasConfig\r\n\r\n  #ctx: CanvasRenderingContext2D | null\r\n  get ctx() {\r\n    return this.#ctx\r\n  }\r\n\r\n  #canvas: HTMLCanvasElement\r\n  get canvas() {\r\n    return this.#canvas\r\n  }\r\n  set canvas(canvas: HTMLCanvasElement) {\r\n    this.#canvas = canvas\r\n    this.#ctx = canvas.getContext('2d')\r\n  }\r\n\r\n  constructor(canvas: HTMLCanvasElement, config: Partial<SnowfallCanvasConfig>) {\r\n    this.#canvas = canvas\r\n    this.#ctx = canvas.getContext('2d')\r\n    this.config = { snowflakeCount: 150, ...defaultConfig, ...config }\r\n    this.snowflakes = []\r\n    this.snowflakes = Snowflake.createSnowflakes(canvas, config.snowflakeCount || 150, config)\r\n    this.play()\r\n  }\r\n\r\n  /**\r\n   * Updates the config used for the snowfall animation, if the number of snowflakes\r\n   * has changed then this will create new or remove existing snowflakes gracefully\r\n   * to retain the position of as many existing snowflakes as possible.\r\n   */\r\n  updateConfig(config: Partial<SnowfallCanvasConfig>) {\r\n    this.config = { ...this.config, ...config }\r\n\r\n    const sizeDifference = this.config.snowflakeCount - this.snowflakes.length\r\n\r\n    if (sizeDifference > 0) {\r\n      this.snowflakes = [...this.snowflakes, ...Snowflake.createSnowflakes(this.canvas, sizeDifference, config)]\r\n    }\r\n\r\n    if (sizeDifference < 0) {\r\n      this.snowflakes = this.snowflakes.slice(0, this.config.snowflakeCount)\r\n    }\r\n\r\n    for (const snowflake of this.snowflakes) {\r\n      snowflake.updateConfig(this.config)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the location of each snowflake based on the number of frames passed then\r\n   * clears the canvas and draws each snowflake.\r\n   */\r\n  private render(framesPassed = 1) {\r\n    const { ctx, canvas, snowflakes } = this\r\n\r\n    if (!ctx || !canvas) return\r\n\r\n    const { offsetWidth, offsetHeight } = canvas\r\n\r\n    // Update the position of each snowflake\r\n    for (const snowflake of snowflakes) {\r\n      snowflake.update(offsetWidth, offsetHeight, framesPassed)\r\n    }\r\n\r\n    // Render the snowflakes\r\n    ctx.setTransform(1, 0, 0, 1, 0, 0)\r\n    ctx.clearRect(0, 0, offsetWidth, offsetHeight)\r\n\r\n    // If using images, draw each image individually\r\n    if (this.config.images && this.config.images.length > 0) {\r\n      for (const snowflake of snowflakes) {\r\n        snowflake.drawImage(ctx)\r\n      }\r\n      return\r\n    }\r\n\r\n    // Not using images, draw circles in a single path\r\n    ctx.beginPath()\r\n    for (const snowflake of snowflakes) {\r\n      snowflake.drawCircle(ctx)\r\n    }\r\n    ctx.fillStyle = this.config.color!\r\n    ctx.fill()\r\n  }\r\n\r\n  private animationFrame: number | undefined\r\n\r\n  /**\r\n   * The animation loop, will calculate the time since the last render and update\r\n   * the position of the snowflakes appropriately before queueing another frame.\r\n   */\r\n  private loop() {\r\n    // Update based on time passed so that a slow frame rate won't slow down the snowflake\r\n    const now = Date.now()\r\n    const msPassed = Date.now() - this.lastUpdate\r\n    this.lastUpdate = now\r\n\r\n    // Frames that would have passed if running at 60 fps\r\n    const framesPassed = msPassed / targetFrameTime\r\n\r\n    this.render(framesPassed)\r\n\r\n    this.animationFrame = requestAnimationFrame(() => this.loop())\r\n  }\r\n\r\n  /** Start the animation playing. */\r\n  play() {\r\n    this.loop()\r\n  }\r\n\r\n  /** Pause the animation. */\r\n  pause() {\r\n    if (this.animationFrame) {\r\n      cancelAnimationFrame(this.animationFrame)\r\n      this.animationFrame = undefined\r\n    }\r\n  }\r\n}\r\n\r\nexport default SnowfallCanvas\r\n"]},"metadata":{},"sourceType":"module"}